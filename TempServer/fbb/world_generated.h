// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORLD_H_
#define FLATBUFFERS_GENERATED_WORLD_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

struct EnterNeighborsNfy;
struct EnterNeighborsNfyBuilder;
struct EnterNeighborsNfyT;

struct LeaveNeighborsNfy;
struct LeaveNeighborsNfyBuilder;
struct LeaveNeighborsNfyT;

struct UpdateNeighborsNfy;
struct UpdateNeighborsNfyBuilder;
struct UpdateNeighborsNfyT;

struct MoveReq;
struct MoveReqBuilder;
struct MoveReqT;

struct MoveAck;
struct MoveAckBuilder;
struct MoveAckT;

struct MoveNfy;
struct MoveNfyBuilder;
struct MoveNfyT;

struct EnterWorldReq;
struct EnterWorldReqBuilder;
struct EnterWorldReqT;

struct EnterWorldAck;
struct EnterWorldAckBuilder;
struct EnterWorldAckT;

struct EnterNeighborsNfyT : public flatbuffers::NativeTable {
  typedef EnterNeighborsNfy TableType;
  std::unique_ptr<EntityInfo> enter_entity;
  EnterNeighborsNfyT() {
  }
};

struct EnterNeighborsNfy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterNeighborsNfyT NativeTableType;
  typedef EnterNeighborsNfyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTER_ENTITY = 4
  };
  const EntityInfo *enter_entity() const {
    return GetStruct<const EntityInfo *>(VT_ENTER_ENTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<EntityInfo>(verifier, VT_ENTER_ENTITY) &&
           verifier.EndTable();
  }
  EnterNeighborsNfyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterNeighborsNfyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterNeighborsNfy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterNeighborsNfyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterNeighborsNfyBuilder {
  typedef EnterNeighborsNfy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enter_entity(const EntityInfo *enter_entity) {
    fbb_.AddStruct(EnterNeighborsNfy::VT_ENTER_ENTITY, enter_entity);
  }
  explicit EnterNeighborsNfyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterNeighborsNfyBuilder &operator=(const EnterNeighborsNfyBuilder &);
  flatbuffers::Offset<EnterNeighborsNfy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterNeighborsNfy>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterNeighborsNfy> CreateEnterNeighborsNfy(
    flatbuffers::FlatBufferBuilder &_fbb,
    const EntityInfo *enter_entity = 0) {
  EnterNeighborsNfyBuilder builder_(_fbb);
  builder_.add_enter_entity(enter_entity);
  return builder_.Finish();
}

flatbuffers::Offset<EnterNeighborsNfy> CreateEnterNeighborsNfy(flatbuffers::FlatBufferBuilder &_fbb, const EnterNeighborsNfyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeaveNeighborsNfyT : public flatbuffers::NativeTable {
  typedef LeaveNeighborsNfy TableType;
  uint32_t leave_entity;
  LeaveNeighborsNfyT()
      : leave_entity(0) {
  }
};

struct LeaveNeighborsNfy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeaveNeighborsNfyT NativeTableType;
  typedef LeaveNeighborsNfyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEAVE_ENTITY = 4
  };
  uint32_t leave_entity() const {
    return GetField<uint32_t>(VT_LEAVE_ENTITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LEAVE_ENTITY) &&
           verifier.EndTable();
  }
  LeaveNeighborsNfyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeaveNeighborsNfyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeaveNeighborsNfy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaveNeighborsNfyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeaveNeighborsNfyBuilder {
  typedef LeaveNeighborsNfy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_leave_entity(uint32_t leave_entity) {
    fbb_.AddElement<uint32_t>(LeaveNeighborsNfy::VT_LEAVE_ENTITY, leave_entity, 0);
  }
  explicit LeaveNeighborsNfyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeaveNeighborsNfyBuilder &operator=(const LeaveNeighborsNfyBuilder &);
  flatbuffers::Offset<LeaveNeighborsNfy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeaveNeighborsNfy>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeaveNeighborsNfy> CreateLeaveNeighborsNfy(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t leave_entity = 0) {
  LeaveNeighborsNfyBuilder builder_(_fbb);
  builder_.add_leave_entity(leave_entity);
  return builder_.Finish();
}

flatbuffers::Offset<LeaveNeighborsNfy> CreateLeaveNeighborsNfy(flatbuffers::FlatBufferBuilder &_fbb, const LeaveNeighborsNfyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpdateNeighborsNfyT : public flatbuffers::NativeTable {
  typedef UpdateNeighborsNfy TableType;
  std::vector<EntityInfo> enter_entity;
  std::vector<uint32_t> leave_entity;
  UpdateNeighborsNfyT() {
  }
};

struct UpdateNeighborsNfy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UpdateNeighborsNfyT NativeTableType;
  typedef UpdateNeighborsNfyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTER_ENTITY = 4,
    VT_LEAVE_ENTITY = 6
  };
  const flatbuffers::Vector<const EntityInfo *> *enter_entity() const {
    return GetPointer<const flatbuffers::Vector<const EntityInfo *> *>(VT_ENTER_ENTITY);
  }
  const flatbuffers::Vector<uint32_t> *leave_entity() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_LEAVE_ENTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTER_ENTITY) &&
           verifier.VerifyVector(enter_entity()) &&
           VerifyOffset(verifier, VT_LEAVE_ENTITY) &&
           verifier.VerifyVector(leave_entity()) &&
           verifier.EndTable();
  }
  UpdateNeighborsNfyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpdateNeighborsNfyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UpdateNeighborsNfy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpdateNeighborsNfyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpdateNeighborsNfyBuilder {
  typedef UpdateNeighborsNfy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enter_entity(flatbuffers::Offset<flatbuffers::Vector<const EntityInfo *>> enter_entity) {
    fbb_.AddOffset(UpdateNeighborsNfy::VT_ENTER_ENTITY, enter_entity);
  }
  void add_leave_entity(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> leave_entity) {
    fbb_.AddOffset(UpdateNeighborsNfy::VT_LEAVE_ENTITY, leave_entity);
  }
  explicit UpdateNeighborsNfyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateNeighborsNfyBuilder &operator=(const UpdateNeighborsNfyBuilder &);
  flatbuffers::Offset<UpdateNeighborsNfy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateNeighborsNfy>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpdateNeighborsNfy> CreateUpdateNeighborsNfy(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const EntityInfo *>> enter_entity = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> leave_entity = 0) {
  UpdateNeighborsNfyBuilder builder_(_fbb);
  builder_.add_leave_entity(leave_entity);
  builder_.add_enter_entity(enter_entity);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpdateNeighborsNfy> CreateUpdateNeighborsNfyDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<EntityInfo> *enter_entity = nullptr,
    const std::vector<uint32_t> *leave_entity = nullptr) {
  auto enter_entity__ = enter_entity ? _fbb.CreateVectorOfStructs<EntityInfo>(*enter_entity) : 0;
  auto leave_entity__ = leave_entity ? _fbb.CreateVector<uint32_t>(*leave_entity) : 0;
  return CreateUpdateNeighborsNfy(
      _fbb,
      enter_entity__,
      leave_entity__);
}

flatbuffers::Offset<UpdateNeighborsNfy> CreateUpdateNeighborsNfy(flatbuffers::FlatBufferBuilder &_fbb, const UpdateNeighborsNfyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveReqT : public flatbuffers::NativeTable {
  typedef MoveReq TableType;
  std::unique_ptr<fbVec> dest;
  MoveReqT() {
  }
};

struct MoveReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveReqT NativeTableType;
  typedef MoveReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEST = 4
  };
  const fbVec *dest() const {
    return GetStruct<const fbVec *>(VT_DEST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fbVec>(verifier, VT_DEST) &&
           verifier.EndTable();
  }
  MoveReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveReqBuilder {
  typedef MoveReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dest(const fbVec *dest) {
    fbb_.AddStruct(MoveReq::VT_DEST, dest);
  }
  explicit MoveReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveReqBuilder &operator=(const MoveReqBuilder &);
  flatbuffers::Offset<MoveReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveReq> CreateMoveReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fbVec *dest = 0) {
  MoveReqBuilder builder_(_fbb);
  builder_.add_dest(dest);
  return builder_.Finish();
}

flatbuffers::Offset<MoveReq> CreateMoveReq(flatbuffers::FlatBufferBuilder &_fbb, const MoveReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveAckT : public flatbuffers::NativeTable {
  typedef MoveAck TableType;
  ErrorCode error_code;
  MoveAckT()
      : error_code(ErrorCode::None) {
  }
};

struct MoveAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveAckT NativeTableType;
  typedef MoveAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<uint16_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  MoveAckT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveAckT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveAck> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveAckT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveAckBuilder {
  typedef MoveAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<uint16_t>(MoveAck::VT_ERROR_CODE, static_cast<uint16_t>(error_code), 0);
  }
  explicit MoveAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveAckBuilder &operator=(const MoveAckBuilder &);
  flatbuffers::Offset<MoveAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveAck> CreateMoveAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode::None) {
  MoveAckBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<MoveAck> CreateMoveAck(flatbuffers::FlatBufferBuilder &_fbb, const MoveAckT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveNfyT : public flatbuffers::NativeTable {
  typedef MoveNfy TableType;
  std::unique_ptr<fbVec> dest;
  float spd;
  uint32_t eid;
  MoveNfyT()
      : spd(0.0f),
        eid(0) {
  }
};

struct MoveNfy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveNfyT NativeTableType;
  typedef MoveNfyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEST = 4,
    VT_SPD = 6,
    VT_EID = 8
  };
  const fbVec *dest() const {
    return GetStruct<const fbVec *>(VT_DEST);
  }
  float spd() const {
    return GetField<float>(VT_SPD, 0.0f);
  }
  uint32_t eid() const {
    return GetField<uint32_t>(VT_EID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fbVec>(verifier, VT_DEST) &&
           VerifyField<float>(verifier, VT_SPD) &&
           VerifyField<uint32_t>(verifier, VT_EID) &&
           verifier.EndTable();
  }
  MoveNfyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveNfyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveNfy> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveNfyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveNfyBuilder {
  typedef MoveNfy Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dest(const fbVec *dest) {
    fbb_.AddStruct(MoveNfy::VT_DEST, dest);
  }
  void add_spd(float spd) {
    fbb_.AddElement<float>(MoveNfy::VT_SPD, spd, 0.0f);
  }
  void add_eid(uint32_t eid) {
    fbb_.AddElement<uint32_t>(MoveNfy::VT_EID, eid, 0);
  }
  explicit MoveNfyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveNfyBuilder &operator=(const MoveNfyBuilder &);
  flatbuffers::Offset<MoveNfy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveNfy>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveNfy> CreateMoveNfy(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fbVec *dest = 0,
    float spd = 0.0f,
    uint32_t eid = 0) {
  MoveNfyBuilder builder_(_fbb);
  builder_.add_eid(eid);
  builder_.add_spd(spd);
  builder_.add_dest(dest);
  return builder_.Finish();
}

flatbuffers::Offset<MoveNfy> CreateMoveNfy(flatbuffers::FlatBufferBuilder &_fbb, const MoveNfyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnterWorldReqT : public flatbuffers::NativeTable {
  typedef EnterWorldReq TableType;
  uint32_t eid;
  EnterWorldReqT()
      : eid(0) {
  }
};

struct EnterWorldReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterWorldReqT NativeTableType;
  typedef EnterWorldReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EID = 4
  };
  uint32_t eid() const {
    return GetField<uint32_t>(VT_EID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EID) &&
           verifier.EndTable();
  }
  EnterWorldReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterWorldReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterWorldReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterWorldReqBuilder {
  typedef EnterWorldReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eid(uint32_t eid) {
    fbb_.AddElement<uint32_t>(EnterWorldReq::VT_EID, eid, 0);
  }
  explicit EnterWorldReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterWorldReqBuilder &operator=(const EnterWorldReqBuilder &);
  flatbuffers::Offset<EnterWorldReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterWorldReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterWorldReq> CreateEnterWorldReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t eid = 0) {
  EnterWorldReqBuilder builder_(_fbb);
  builder_.add_eid(eid);
  return builder_.Finish();
}

flatbuffers::Offset<EnterWorldReq> CreateEnterWorldReq(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnterWorldAckT : public flatbuffers::NativeTable {
  typedef EnterWorldAck TableType;
  std::unique_ptr<EntityInfo> entity;
  EnterWorldAckT() {
  }
};

struct EnterWorldAck FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterWorldAckT NativeTableType;
  typedef EnterWorldAckBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITY = 4
  };
  const EntityInfo *entity() const {
    return GetStruct<const EntityInfo *>(VT_ENTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<EntityInfo>(verifier, VT_ENTITY) &&
           verifier.EndTable();
  }
  EnterWorldAckT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterWorldAckT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterWorldAck> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldAckT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterWorldAckBuilder {
  typedef EnterWorldAck Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity(const EntityInfo *entity) {
    fbb_.AddStruct(EnterWorldAck::VT_ENTITY, entity);
  }
  explicit EnterWorldAckBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterWorldAckBuilder &operator=(const EnterWorldAckBuilder &);
  flatbuffers::Offset<EnterWorldAck> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterWorldAck>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterWorldAck> CreateEnterWorldAck(
    flatbuffers::FlatBufferBuilder &_fbb,
    const EntityInfo *entity = 0) {
  EnterWorldAckBuilder builder_(_fbb);
  builder_.add_entity(entity);
  return builder_.Finish();
}

flatbuffers::Offset<EnterWorldAck> CreateEnterWorldAck(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldAckT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EnterNeighborsNfyT *EnterNeighborsNfy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EnterNeighborsNfyT> _o = std::unique_ptr<EnterNeighborsNfyT>(new EnterNeighborsNfyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnterNeighborsNfy::UnPackTo(EnterNeighborsNfyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enter_entity(); if (_e) _o->enter_entity = std::unique_ptr<EntityInfo>(new EntityInfo(*_e)); }
}

inline flatbuffers::Offset<EnterNeighborsNfy> EnterNeighborsNfy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterNeighborsNfyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterNeighborsNfy(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterNeighborsNfy> CreateEnterNeighborsNfy(flatbuffers::FlatBufferBuilder &_fbb, const EnterNeighborsNfyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnterNeighborsNfyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enter_entity = _o->enter_entity ? _o->enter_entity.get() : 0;
  return CreateEnterNeighborsNfy(
      _fbb,
      _enter_entity);
}

inline LeaveNeighborsNfyT *LeaveNeighborsNfy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<LeaveNeighborsNfyT> _o = std::unique_ptr<LeaveNeighborsNfyT>(new LeaveNeighborsNfyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeaveNeighborsNfy::UnPackTo(LeaveNeighborsNfyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = leave_entity(); _o->leave_entity = _e; }
}

inline flatbuffers::Offset<LeaveNeighborsNfy> LeaveNeighborsNfy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaveNeighborsNfyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeaveNeighborsNfy(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeaveNeighborsNfy> CreateLeaveNeighborsNfy(flatbuffers::FlatBufferBuilder &_fbb, const LeaveNeighborsNfyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeaveNeighborsNfyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _leave_entity = _o->leave_entity;
  return CreateLeaveNeighborsNfy(
      _fbb,
      _leave_entity);
}

inline UpdateNeighborsNfyT *UpdateNeighborsNfy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<UpdateNeighborsNfyT> _o = std::unique_ptr<UpdateNeighborsNfyT>(new UpdateNeighborsNfyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UpdateNeighborsNfy::UnPackTo(UpdateNeighborsNfyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enter_entity(); if (_e) { _o->enter_entity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->enter_entity[_i] = *_e->Get(_i); } } }
  { auto _e = leave_entity(); if (_e) { _o->leave_entity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->leave_entity[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<UpdateNeighborsNfy> UpdateNeighborsNfy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpdateNeighborsNfyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpdateNeighborsNfy(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UpdateNeighborsNfy> CreateUpdateNeighborsNfy(flatbuffers::FlatBufferBuilder &_fbb, const UpdateNeighborsNfyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UpdateNeighborsNfyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enter_entity = _o->enter_entity.size() ? _fbb.CreateVectorOfStructs(_o->enter_entity) : 0;
  auto _leave_entity = _o->leave_entity.size() ? _fbb.CreateVector(_o->leave_entity) : 0;
  return CreateUpdateNeighborsNfy(
      _fbb,
      _enter_entity,
      _leave_entity);
}

inline MoveReqT *MoveReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MoveReqT> _o = std::unique_ptr<MoveReqT>(new MoveReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveReq::UnPackTo(MoveReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dest(); if (_e) _o->dest = std::unique_ptr<fbVec>(new fbVec(*_e)); }
}

inline flatbuffers::Offset<MoveReq> MoveReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveReq> CreateMoveReq(flatbuffers::FlatBufferBuilder &_fbb, const MoveReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoveReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dest = _o->dest ? _o->dest.get() : 0;
  return CreateMoveReq(
      _fbb,
      _dest);
}

inline MoveAckT *MoveAck::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MoveAckT> _o = std::unique_ptr<MoveAckT>(new MoveAckT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveAck::UnPackTo(MoveAckT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; }
}

inline flatbuffers::Offset<MoveAck> MoveAck::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveAckT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveAck(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveAck> CreateMoveAck(flatbuffers::FlatBufferBuilder &_fbb, const MoveAckT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoveAckT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error_code = _o->error_code;
  return CreateMoveAck(
      _fbb,
      _error_code);
}

inline MoveNfyT *MoveNfy::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MoveNfyT> _o = std::unique_ptr<MoveNfyT>(new MoveNfyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveNfy::UnPackTo(MoveNfyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dest(); if (_e) _o->dest = std::unique_ptr<fbVec>(new fbVec(*_e)); }
  { auto _e = spd(); _o->spd = _e; }
  { auto _e = eid(); _o->eid = _e; }
}

inline flatbuffers::Offset<MoveNfy> MoveNfy::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveNfyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveNfy(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveNfy> CreateMoveNfy(flatbuffers::FlatBufferBuilder &_fbb, const MoveNfyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoveNfyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dest = _o->dest ? _o->dest.get() : 0;
  auto _spd = _o->spd;
  auto _eid = _o->eid;
  return CreateMoveNfy(
      _fbb,
      _dest,
      _spd,
      _eid);
}

inline EnterWorldReqT *EnterWorldReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EnterWorldReqT> _o = std::unique_ptr<EnterWorldReqT>(new EnterWorldReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnterWorldReq::UnPackTo(EnterWorldReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = eid(); _o->eid = _e; }
}

inline flatbuffers::Offset<EnterWorldReq> EnterWorldReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterWorldReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterWorldReq> CreateEnterWorldReq(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnterWorldReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _eid = _o->eid;
  return CreateEnterWorldReq(
      _fbb,
      _eid);
}

inline EnterWorldAckT *EnterWorldAck::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EnterWorldAckT> _o = std::unique_ptr<EnterWorldAckT>(new EnterWorldAckT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnterWorldAck::UnPackTo(EnterWorldAckT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity(); if (_e) _o->entity = std::unique_ptr<EntityInfo>(new EntityInfo(*_e)); }
}

inline flatbuffers::Offset<EnterWorldAck> EnterWorldAck::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldAckT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterWorldAck(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterWorldAck> CreateEnterWorldAck(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldAckT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnterWorldAckT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _entity = _o->entity ? _o->entity.get() : 0;
  return CreateEnterWorldAck(
      _fbb,
      _entity);
}

#endif  // FLATBUFFERS_GENERATED_WORLD_H_
