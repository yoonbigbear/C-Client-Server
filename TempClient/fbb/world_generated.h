// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORLD_H_
#define FLATBUFFERS_GENERATED_WORLD_H_

#include "flatbuffers/flatbuffers.h"

#include "common_generated.h"

struct EnterNeighborsSync;
struct EnterNeighborsSyncBuilder;
struct EnterNeighborsSyncT;

struct LeaveNeighborsSync;
struct LeaveNeighborsSyncBuilder;
struct LeaveNeighborsSyncT;

struct UpdateNeighborsSync;
struct UpdateNeighborsSyncBuilder;
struct UpdateNeighborsSyncT;

struct MoveReq;
struct MoveReqBuilder;
struct MoveReqT;

struct MoveResp;
struct MoveRespBuilder;
struct MoveRespT;

struct MoveSync;
struct MoveSyncBuilder;
struct MoveSyncT;

struct EnterWorldReq;
struct EnterWorldReqBuilder;
struct EnterWorldReqT;

struct EnterWorldResp;
struct EnterWorldRespBuilder;
struct EnterWorldRespT;

struct EnterNeighborsSyncT : public flatbuffers::NativeTable {
  typedef EnterNeighborsSync TableType;
  std::unique_ptr<EntityInfo> enter_entity;
  EnterNeighborsSyncT() {
  }
};

struct EnterNeighborsSync FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterNeighborsSyncT NativeTableType;
  typedef EnterNeighborsSyncBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTER_ENTITY = 4
  };
  const EntityInfo *enter_entity() const {
    return GetStruct<const EntityInfo *>(VT_ENTER_ENTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<EntityInfo>(verifier, VT_ENTER_ENTITY) &&
           verifier.EndTable();
  }
  EnterNeighborsSyncT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterNeighborsSyncT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterNeighborsSync> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterNeighborsSyncT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterNeighborsSyncBuilder {
  typedef EnterNeighborsSync Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enter_entity(const EntityInfo *enter_entity) {
    fbb_.AddStruct(EnterNeighborsSync::VT_ENTER_ENTITY, enter_entity);
  }
  explicit EnterNeighborsSyncBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterNeighborsSyncBuilder &operator=(const EnterNeighborsSyncBuilder &);
  flatbuffers::Offset<EnterNeighborsSync> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterNeighborsSync>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterNeighborsSync> CreateEnterNeighborsSync(
    flatbuffers::FlatBufferBuilder &_fbb,
    const EntityInfo *enter_entity = 0) {
  EnterNeighborsSyncBuilder builder_(_fbb);
  builder_.add_enter_entity(enter_entity);
  return builder_.Finish();
}

flatbuffers::Offset<EnterNeighborsSync> CreateEnterNeighborsSync(flatbuffers::FlatBufferBuilder &_fbb, const EnterNeighborsSyncT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LeaveNeighborsSyncT : public flatbuffers::NativeTable {
  typedef LeaveNeighborsSync TableType;
  uint32_t leave_entity;
  LeaveNeighborsSyncT()
      : leave_entity(0) {
  }
};

struct LeaveNeighborsSync FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LeaveNeighborsSyncT NativeTableType;
  typedef LeaveNeighborsSyncBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEAVE_ENTITY = 4
  };
  uint32_t leave_entity() const {
    return GetField<uint32_t>(VT_LEAVE_ENTITY, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_LEAVE_ENTITY) &&
           verifier.EndTable();
  }
  LeaveNeighborsSyncT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LeaveNeighborsSyncT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LeaveNeighborsSync> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaveNeighborsSyncT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LeaveNeighborsSyncBuilder {
  typedef LeaveNeighborsSync Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_leave_entity(uint32_t leave_entity) {
    fbb_.AddElement<uint32_t>(LeaveNeighborsSync::VT_LEAVE_ENTITY, leave_entity, 0);
  }
  explicit LeaveNeighborsSyncBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeaveNeighborsSyncBuilder &operator=(const LeaveNeighborsSyncBuilder &);
  flatbuffers::Offset<LeaveNeighborsSync> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeaveNeighborsSync>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeaveNeighborsSync> CreateLeaveNeighborsSync(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t leave_entity = 0) {
  LeaveNeighborsSyncBuilder builder_(_fbb);
  builder_.add_leave_entity(leave_entity);
  return builder_.Finish();
}

flatbuffers::Offset<LeaveNeighborsSync> CreateLeaveNeighborsSync(flatbuffers::FlatBufferBuilder &_fbb, const LeaveNeighborsSyncT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct UpdateNeighborsSyncT : public flatbuffers::NativeTable {
  typedef UpdateNeighborsSync TableType;
  std::vector<EntityInfo> enter_entity;
  std::vector<uint32_t> leave_entity;
  UpdateNeighborsSyncT() {
  }
};

struct UpdateNeighborsSync FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef UpdateNeighborsSyncT NativeTableType;
  typedef UpdateNeighborsSyncBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTER_ENTITY = 4,
    VT_LEAVE_ENTITY = 6
  };
  const flatbuffers::Vector<const EntityInfo *> *enter_entity() const {
    return GetPointer<const flatbuffers::Vector<const EntityInfo *> *>(VT_ENTER_ENTITY);
  }
  const flatbuffers::Vector<uint32_t> *leave_entity() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_LEAVE_ENTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ENTER_ENTITY) &&
           verifier.VerifyVector(enter_entity()) &&
           VerifyOffset(verifier, VT_LEAVE_ENTITY) &&
           verifier.VerifyVector(leave_entity()) &&
           verifier.EndTable();
  }
  UpdateNeighborsSyncT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(UpdateNeighborsSyncT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<UpdateNeighborsSync> Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpdateNeighborsSyncT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct UpdateNeighborsSyncBuilder {
  typedef UpdateNeighborsSync Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_enter_entity(flatbuffers::Offset<flatbuffers::Vector<const EntityInfo *>> enter_entity) {
    fbb_.AddOffset(UpdateNeighborsSync::VT_ENTER_ENTITY, enter_entity);
  }
  void add_leave_entity(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> leave_entity) {
    fbb_.AddOffset(UpdateNeighborsSync::VT_LEAVE_ENTITY, leave_entity);
  }
  explicit UpdateNeighborsSyncBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpdateNeighborsSyncBuilder &operator=(const UpdateNeighborsSyncBuilder &);
  flatbuffers::Offset<UpdateNeighborsSync> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UpdateNeighborsSync>(end);
    return o;
  }
};

inline flatbuffers::Offset<UpdateNeighborsSync> CreateUpdateNeighborsSync(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const EntityInfo *>> enter_entity = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> leave_entity = 0) {
  UpdateNeighborsSyncBuilder builder_(_fbb);
  builder_.add_leave_entity(leave_entity);
  builder_.add_enter_entity(enter_entity);
  return builder_.Finish();
}

inline flatbuffers::Offset<UpdateNeighborsSync> CreateUpdateNeighborsSyncDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<EntityInfo> *enter_entity = nullptr,
    const std::vector<uint32_t> *leave_entity = nullptr) {
  auto enter_entity__ = enter_entity ? _fbb.CreateVectorOfStructs<EntityInfo>(*enter_entity) : 0;
  auto leave_entity__ = leave_entity ? _fbb.CreateVector<uint32_t>(*leave_entity) : 0;
  return CreateUpdateNeighborsSync(
      _fbb,
      enter_entity__,
      leave_entity__);
}

flatbuffers::Offset<UpdateNeighborsSync> CreateUpdateNeighborsSync(flatbuffers::FlatBufferBuilder &_fbb, const UpdateNeighborsSyncT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveReqT : public flatbuffers::NativeTable {
  typedef MoveReq TableType;
  std::unique_ptr<fbVec> dest;
  MoveReqT() {
  }
};

struct MoveReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveReqT NativeTableType;
  typedef MoveReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEST = 4
  };
  const fbVec *dest() const {
    return GetStruct<const fbVec *>(VT_DEST);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fbVec>(verifier, VT_DEST) &&
           verifier.EndTable();
  }
  MoveReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveReqBuilder {
  typedef MoveReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dest(const fbVec *dest) {
    fbb_.AddStruct(MoveReq::VT_DEST, dest);
  }
  explicit MoveReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveReqBuilder &operator=(const MoveReqBuilder &);
  flatbuffers::Offset<MoveReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveReq> CreateMoveReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fbVec *dest = 0) {
  MoveReqBuilder builder_(_fbb);
  builder_.add_dest(dest);
  return builder_.Finish();
}

flatbuffers::Offset<MoveReq> CreateMoveReq(flatbuffers::FlatBufferBuilder &_fbb, const MoveReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveRespT : public flatbuffers::NativeTable {
  typedef MoveResp TableType;
  ErrorCode error_code;
  MoveRespT()
      : error_code(ErrorCode::None) {
  }
};

struct MoveResp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveRespT NativeTableType;
  typedef MoveRespBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ERROR_CODE = 4
  };
  ErrorCode error_code() const {
    return static_cast<ErrorCode>(GetField<uint16_t>(VT_ERROR_CODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint16_t>(verifier, VT_ERROR_CODE) &&
           verifier.EndTable();
  }
  MoveRespT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveRespT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveResp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveRespT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveRespBuilder {
  typedef MoveResp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_error_code(ErrorCode error_code) {
    fbb_.AddElement<uint16_t>(MoveResp::VT_ERROR_CODE, static_cast<uint16_t>(error_code), 0);
  }
  explicit MoveRespBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveRespBuilder &operator=(const MoveRespBuilder &);
  flatbuffers::Offset<MoveResp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveResp>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveResp> CreateMoveResp(
    flatbuffers::FlatBufferBuilder &_fbb,
    ErrorCode error_code = ErrorCode::None) {
  MoveRespBuilder builder_(_fbb);
  builder_.add_error_code(error_code);
  return builder_.Finish();
}

flatbuffers::Offset<MoveResp> CreateMoveResp(flatbuffers::FlatBufferBuilder &_fbb, const MoveRespT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoveSyncT : public flatbuffers::NativeTable {
  typedef MoveSync TableType;
  std::unique_ptr<fbVec> dest;
  float spd;
  uint32_t eid;
  MoveSyncT()
      : spd(0.0f),
        eid(0) {
  }
};

struct MoveSync FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoveSyncT NativeTableType;
  typedef MoveSyncBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEST = 4,
    VT_SPD = 6,
    VT_EID = 8
  };
  const fbVec *dest() const {
    return GetStruct<const fbVec *>(VT_DEST);
  }
  float spd() const {
    return GetField<float>(VT_SPD, 0.0f);
  }
  uint32_t eid() const {
    return GetField<uint32_t>(VT_EID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<fbVec>(verifier, VT_DEST) &&
           VerifyField<float>(verifier, VT_SPD) &&
           VerifyField<uint32_t>(verifier, VT_EID) &&
           verifier.EndTable();
  }
  MoveSyncT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoveSyncT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoveSync> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveSyncT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoveSyncBuilder {
  typedef MoveSync Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dest(const fbVec *dest) {
    fbb_.AddStruct(MoveSync::VT_DEST, dest);
  }
  void add_spd(float spd) {
    fbb_.AddElement<float>(MoveSync::VT_SPD, spd, 0.0f);
  }
  void add_eid(uint32_t eid) {
    fbb_.AddElement<uint32_t>(MoveSync::VT_EID, eid, 0);
  }
  explicit MoveSyncBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MoveSyncBuilder &operator=(const MoveSyncBuilder &);
  flatbuffers::Offset<MoveSync> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoveSync>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoveSync> CreateMoveSync(
    flatbuffers::FlatBufferBuilder &_fbb,
    const fbVec *dest = 0,
    float spd = 0.0f,
    uint32_t eid = 0) {
  MoveSyncBuilder builder_(_fbb);
  builder_.add_eid(eid);
  builder_.add_spd(spd);
  builder_.add_dest(dest);
  return builder_.Finish();
}

flatbuffers::Offset<MoveSync> CreateMoveSync(flatbuffers::FlatBufferBuilder &_fbb, const MoveSyncT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnterWorldReqT : public flatbuffers::NativeTable {
  typedef EnterWorldReq TableType;
  uint32_t eid;
  EnterWorldReqT()
      : eid(0) {
  }
};

struct EnterWorldReq FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterWorldReqT NativeTableType;
  typedef EnterWorldReqBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EID = 4
  };
  uint32_t eid() const {
    return GetField<uint32_t>(VT_EID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_EID) &&
           verifier.EndTable();
  }
  EnterWorldReqT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterWorldReqT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterWorldReq> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldReqT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterWorldReqBuilder {
  typedef EnterWorldReq Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eid(uint32_t eid) {
    fbb_.AddElement<uint32_t>(EnterWorldReq::VT_EID, eid, 0);
  }
  explicit EnterWorldReqBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterWorldReqBuilder &operator=(const EnterWorldReqBuilder &);
  flatbuffers::Offset<EnterWorldReq> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterWorldReq>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterWorldReq> CreateEnterWorldReq(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t eid = 0) {
  EnterWorldReqBuilder builder_(_fbb);
  builder_.add_eid(eid);
  return builder_.Finish();
}

flatbuffers::Offset<EnterWorldReq> CreateEnterWorldReq(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldReqT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EnterWorldRespT : public flatbuffers::NativeTable {
  typedef EnterWorldResp TableType;
  std::unique_ptr<EntityInfo> entity;
  EnterWorldRespT() {
  }
};

struct EnterWorldResp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EnterWorldRespT NativeTableType;
  typedef EnterWorldRespBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ENTITY = 4
  };
  const EntityInfo *entity() const {
    return GetStruct<const EntityInfo *>(VT_ENTITY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<EntityInfo>(verifier, VT_ENTITY) &&
           verifier.EndTable();
  }
  EnterWorldRespT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EnterWorldRespT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<EnterWorldResp> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldRespT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EnterWorldRespBuilder {
  typedef EnterWorldResp Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_entity(const EntityInfo *entity) {
    fbb_.AddStruct(EnterWorldResp::VT_ENTITY, entity);
  }
  explicit EnterWorldRespBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EnterWorldRespBuilder &operator=(const EnterWorldRespBuilder &);
  flatbuffers::Offset<EnterWorldResp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EnterWorldResp>(end);
    return o;
  }
};

inline flatbuffers::Offset<EnterWorldResp> CreateEnterWorldResp(
    flatbuffers::FlatBufferBuilder &_fbb,
    const EntityInfo *entity = 0) {
  EnterWorldRespBuilder builder_(_fbb);
  builder_.add_entity(entity);
  return builder_.Finish();
}

flatbuffers::Offset<EnterWorldResp> CreateEnterWorldResp(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldRespT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline EnterNeighborsSyncT *EnterNeighborsSync::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EnterNeighborsSyncT> _o = std::unique_ptr<EnterNeighborsSyncT>(new EnterNeighborsSyncT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnterNeighborsSync::UnPackTo(EnterNeighborsSyncT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enter_entity(); if (_e) _o->enter_entity = std::unique_ptr<EntityInfo>(new EntityInfo(*_e)); }
}

inline flatbuffers::Offset<EnterNeighborsSync> EnterNeighborsSync::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterNeighborsSyncT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterNeighborsSync(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterNeighborsSync> CreateEnterNeighborsSync(flatbuffers::FlatBufferBuilder &_fbb, const EnterNeighborsSyncT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnterNeighborsSyncT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enter_entity = _o->enter_entity ? _o->enter_entity.get() : 0;
  return CreateEnterNeighborsSync(
      _fbb,
      _enter_entity);
}

inline LeaveNeighborsSyncT *LeaveNeighborsSync::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<LeaveNeighborsSyncT> _o = std::unique_ptr<LeaveNeighborsSyncT>(new LeaveNeighborsSyncT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LeaveNeighborsSync::UnPackTo(LeaveNeighborsSyncT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = leave_entity(); _o->leave_entity = _e; }
}

inline flatbuffers::Offset<LeaveNeighborsSync> LeaveNeighborsSync::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LeaveNeighborsSyncT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLeaveNeighborsSync(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LeaveNeighborsSync> CreateLeaveNeighborsSync(flatbuffers::FlatBufferBuilder &_fbb, const LeaveNeighborsSyncT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LeaveNeighborsSyncT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _leave_entity = _o->leave_entity;
  return CreateLeaveNeighborsSync(
      _fbb,
      _leave_entity);
}

inline UpdateNeighborsSyncT *UpdateNeighborsSync::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<UpdateNeighborsSyncT> _o = std::unique_ptr<UpdateNeighborsSyncT>(new UpdateNeighborsSyncT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void UpdateNeighborsSync::UnPackTo(UpdateNeighborsSyncT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = enter_entity(); if (_e) { _o->enter_entity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->enter_entity[_i] = *_e->Get(_i); } } }
  { auto _e = leave_entity(); if (_e) { _o->leave_entity.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->leave_entity[_i] = _e->Get(_i); } } }
}

inline flatbuffers::Offset<UpdateNeighborsSync> UpdateNeighborsSync::Pack(flatbuffers::FlatBufferBuilder &_fbb, const UpdateNeighborsSyncT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateUpdateNeighborsSync(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<UpdateNeighborsSync> CreateUpdateNeighborsSync(flatbuffers::FlatBufferBuilder &_fbb, const UpdateNeighborsSyncT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const UpdateNeighborsSyncT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _enter_entity = _o->enter_entity.size() ? _fbb.CreateVectorOfStructs(_o->enter_entity) : 0;
  auto _leave_entity = _o->leave_entity.size() ? _fbb.CreateVector(_o->leave_entity) : 0;
  return CreateUpdateNeighborsSync(
      _fbb,
      _enter_entity,
      _leave_entity);
}

inline MoveReqT *MoveReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MoveReqT> _o = std::unique_ptr<MoveReqT>(new MoveReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveReq::UnPackTo(MoveReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dest(); if (_e) _o->dest = std::unique_ptr<fbVec>(new fbVec(*_e)); }
}

inline flatbuffers::Offset<MoveReq> MoveReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveReq> CreateMoveReq(flatbuffers::FlatBufferBuilder &_fbb, const MoveReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoveReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dest = _o->dest ? _o->dest.get() : 0;
  return CreateMoveReq(
      _fbb,
      _dest);
}

inline MoveRespT *MoveResp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MoveRespT> _o = std::unique_ptr<MoveRespT>(new MoveRespT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveResp::UnPackTo(MoveRespT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = error_code(); _o->error_code = _e; }
}

inline flatbuffers::Offset<MoveResp> MoveResp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveRespT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveResp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveResp> CreateMoveResp(flatbuffers::FlatBufferBuilder &_fbb, const MoveRespT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoveRespT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _error_code = _o->error_code;
  return CreateMoveResp(
      _fbb,
      _error_code);
}

inline MoveSyncT *MoveSync::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<MoveSyncT> _o = std::unique_ptr<MoveSyncT>(new MoveSyncT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoveSync::UnPackTo(MoveSyncT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = dest(); if (_e) _o->dest = std::unique_ptr<fbVec>(new fbVec(*_e)); }
  { auto _e = spd(); _o->spd = _e; }
  { auto _e = eid(); _o->eid = _e; }
}

inline flatbuffers::Offset<MoveSync> MoveSync::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoveSyncT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoveSync(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoveSync> CreateMoveSync(flatbuffers::FlatBufferBuilder &_fbb, const MoveSyncT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoveSyncT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _dest = _o->dest ? _o->dest.get() : 0;
  auto _spd = _o->spd;
  auto _eid = _o->eid;
  return CreateMoveSync(
      _fbb,
      _dest,
      _spd,
      _eid);
}

inline EnterWorldReqT *EnterWorldReq::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EnterWorldReqT> _o = std::unique_ptr<EnterWorldReqT>(new EnterWorldReqT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnterWorldReq::UnPackTo(EnterWorldReqT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = eid(); _o->eid = _e; }
}

inline flatbuffers::Offset<EnterWorldReq> EnterWorldReq::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldReqT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterWorldReq(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterWorldReq> CreateEnterWorldReq(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldReqT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnterWorldReqT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _eid = _o->eid;
  return CreateEnterWorldReq(
      _fbb,
      _eid);
}

inline EnterWorldRespT *EnterWorldResp::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  std::unique_ptr<EnterWorldRespT> _o = std::unique_ptr<EnterWorldRespT>(new EnterWorldRespT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EnterWorldResp::UnPackTo(EnterWorldRespT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = entity(); if (_e) _o->entity = std::unique_ptr<EntityInfo>(new EntityInfo(*_e)); }
}

inline flatbuffers::Offset<EnterWorldResp> EnterWorldResp::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldRespT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEnterWorldResp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<EnterWorldResp> CreateEnterWorldResp(flatbuffers::FlatBufferBuilder &_fbb, const EnterWorldRespT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EnterWorldRespT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _entity = _o->entity ? _o->entity.get() : 0;
  return CreateEnterWorldResp(
      _fbb,
      _entity);
}

#endif  // FLATBUFFERS_GENERATED_WORLD_H_
